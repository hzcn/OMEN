## 深入理解CPU上下文切换

我们都知道CPU上下文切换，会增加系统负载。那什么是CPU上下文，为什么要切换？

​		我们都知道，Linux是一个多任务操作系统，它支持远大于CPU数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将CPU轮流分配给它们，造成多任务同时运行的错觉。

​		而在每个任务运行前，CPU都需要知道任务从哪里加载，又从哪里开始运行，也就是说，需要系统事先帮它设置好CPU寄存器和程序计数器（Program Counter,PC)。CPU寄存器，是CPU内置的容量小、但速度极快的内存。而程序计数器，则是用来存储CPU正在执行的指令谓之、或者即将执行的下一条指令位置。它们都是CPU在运行任何任务前，必须的依赖环境，因此也被叫做CPU上下文。

​		而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。

​		我猜肯定有人会说，CPU上下文切换无非就是更新了CPU寄存器的值嘛，但这些寄存器，本身就是为了快速运行任务而设计的，为什么会影响系统的CPU性能呢？

​		在回答这个问题前，不知道你有没有想过，操作系统管理的这些”任务“到底是什么呢？

​		也许你会说，任务就是进程，或者说任务就是线程，是的进程和线程是最常见的任务，但是除此执外，还有没有其他任务呢？

​		不要忘了，硬件通过触发信号，会导致中断处理程序的调用，这也是一种常见的任务。

​		所以，根据任务的不同，CPU的上下文切换就可以分为几个不同的常见，也就是进程上下文切换，线程上下文切换以及中断上下文切换。

​		下面我们看下如何理解这几个不同的上下文切换，以及他们为什么会引发CPU性能相关的问题。

#### 进程上下文切换

​		Linux按照特权和等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中的CPU特权等级的Ring0和Ring3。

​		内核空间ring0具有最高权限，可以直接访问所有资源

​		用户空间ring3只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。

​		换个角度看，也就是说，进程即可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。

​		从用户态到内核态的转变，需要通过系统调用来完成，比如当我们查看文件内容时，就需要多次系统调用来完成：首先调用open()打开文件，然后调用read()读取文件内容，并调用write()将内容写到标准输出，最后再调用close()关闭文件。

​		那么，系统调用的过程有没有发生CPU上下文切换呢？答案是肯定的。

​		CPU寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。

​		而系统调用结束后，CPU寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程，所以









































